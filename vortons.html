<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>vorts.vortons API documentation</title>
<meta name="description" content="`Vorton`/`Tracer` classes and `Vortons`/`Tracers` container classes." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<!-- MathJax 3, with $..$ for inline math enabled -->
<script>
MathJax = {
tex: {
inlineMath: [['$', '$'], ['\\(', '\\)']]
},
svg: {
fontCache: 'global'
}
};
</script>
<script type="text/javascript" id="MathJax-script" async
src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>vorts.vortons</code></h1>
</header>
<section id="section-intro">
<p><code><a title="vorts.vortons.Vorton" href="#vorts.vortons.Vorton">Vorton</a></code>/<code><a title="vorts.vortons.Tracer" href="#vorts.vortons.Tracer">Tracer</a></code> classes and <code><a title="vorts.vortons.Vortons" href="#vorts.vortons.Vortons">Vortons</a></code>/<code><a title="vorts.vortons.Tracers" href="#vorts.vortons.Tracers">Tracers</a></code> container classes.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/zmoon/vorts/blob/72f11de365abad6b6dc355c92609ad20e8ead8ce/vorts\vortons.py#L0-L682" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;
`Vorton`/`Tracer` classes and `Vortons`/`Tracers` container classes.
&#34;&#34;&#34;
from typing import NamedTuple
import warnings

import numpy as np
import xarray as xr


# new Vorton -- doesn&#39;t know its history, just current state
class Vorton(NamedTuple):
    &#34;&#34;&#34;A vorton that knows its current state (position and strength).&#34;&#34;&#34;
    G: float
    r&#34;&#34;&#34;$\Gamma$, the strength of the circulation, with sign to indicate direction.

    See also
    --------
    Vortons : For a more detailed description.
    &#34;&#34;&#34;
    x: float
    &#34;&#34;&#34;$x$ position&#34;&#34;&#34;
    y: float
    &#34;&#34;&#34;$y$ position&#34;&#34;&#34;


class Tracer(NamedTuple):
    r&#34;&#34;&#34;Tracer -- a vorton with $\Gamma=0$ (no circulation/mass) that knows its current position.&#34;&#34;&#34;
    x: float
    &#34;&#34;&#34;$x$ position&#34;&#34;&#34;
    y: float
    &#34;&#34;&#34;$y$ position&#34;&#34;&#34;


# TODO: PointVortices ABC that implements adding, has position state_mat, n, x, y, state_vec, etc.
#       Vortons and Tracers could both be based on it
#       also should add xy (state_mat for both) and xy_vec (state_vec)


class Tracers:
    &#34;&#34;&#34;Collection of `Tracer`s.&#34;&#34;&#34;
    def __init__(self, x, y):
        &#34;&#34;&#34;
        Parameters
        ----------
        x, y : array_like
            shape: `(n_vortons,)`

            Tracer initial $x$ and $y$ positions.
        &#34;&#34;&#34;
        x = np.asarray(x, dtype=float)
        y = np.asarray(y, dtype=float)

        assert x.shape == y.shape and x.ndim == 1

        self.state_mat = np.column_stack((x, y))


    def __repr__(self):
        # unlike Vortons, might have many tracers
        # so don&#39;t need to show all in the repr
        n = self.n
        return f&#34;Tracers(n={n})&#34;

    @property
    def n(self):
        return self.state_mat.shape[0]

    @property
    def x(self):
        return self.state_mat[:,0]

    @property
    def y(self):
        return self.state_mat[:,1]

    def state_vec(self):
        return self.state_mat.T.flatten()

    def state_mat_full(self):
        &#34;&#34;&#34;Full state mat for tracers doesn&#39;t include G.&#34;&#34;&#34;
        warnings.warn(&#34;Note that `state_mat_full` for tracers is the same as `state_mat` (no G).&#34;)
        return self.state_mat

    @staticmethod
    def randu(n, **kwargs):
        xy = points_randu(n, **kwargs).T
        return Tracers(*xy)

    @staticmethod
    def spiral(n, **kwargs):
        xy = points_spiral(n, **kwargs).T
        return Tracers(*xy)

    def plot(self, *, connect=False):
        import matplotlib.pyplot as plt

        fig, ax = plt.subplots()

        x, y = self.x, self.y
        fmt = &#34;-o&#34; if connect else &#34;o&#34;
        ax.plot(x, y, fmt, c=&#34;0.5&#34;, ms=4, label=&#34;tracers&#34;)

        ax.set(
            xlabel=&#34;$x$&#34;,
            ylabel=&#34;$y$&#34;,
        )
        ax.set_aspect(&#34;equal&#34;, &#34;box&#34;)
        fig.legend()
        ax.grid(True)
        fig.tight_layout()



# could exchange x,y for r at some point, to open 3-d option more easily
class Vortons:
    &#34;&#34;&#34;Collection of `Vorton`s.&#34;&#34;&#34;
    def __init__(self, G, x, y):
        r&#34;&#34;&#34;

        Parameters
        ----------
        G, x, y : array_like
            shape: `(n_vortons,)`

            `G`: $\Gamma$s (&#34;G&#34; for [Gamma](https://en.wikipedia.org/wiki/Gamma)).

            $\Gamma$ represents the strength of the circulation, with sign to indicate direction.
            In fluid dynamics, circulation $\Gamma$ is the line integral of velocity
            or flux of vorticity vectors through a surface (here the $xy$-plane).

            `x`: $x$ positions

            `y`: $y$ positions

        &#34;&#34;&#34;
        self.G = np.asarray(G)
        r&#34;&#34;&#34;Array of vorton strengths ($\Gamma$).&#34;&#34;&#34;
        if np.any(self.G == 0):
            warnings.warn(
                &#34;Tracers should be in a `Tracers` instance. &#34;
                &#34;The ability to add them here may be removed in the future.&#34;
            )

        # the state matrix has shape (n_vortons, n_pos_dims) (G excluded since time-invariant)
        x = np.asarray(x, dtype=float)
        y = np.asarray(y, dtype=float)
        self.state_mat = np.column_stack((x, y))
        &#34;&#34;&#34;2-d array of $(x, y)$ coordinates -- each row is the coordinate of one vorton.&#34;&#34;&#34;

        assert self.G.ndim == 1 and self.state_mat.shape[1] == 2
        assert self.G.size == self.state_mat.shape[0]  # n_vortons

        # create initial corresponding Vorton objects
        self._update_vortons()


    # these 2 don&#39;t really need to be property?
    # maybe shouldn&#39;t be, to emphasize that state_mat is the real data
    # @property
    def state_vec(self):
        &#34;&#34;&#34;Return flattened state matrix (`Vortons.state_mat`; `Vortons.G` not included).

        If using `vorts.py.integ.integrate_scipy`,
        this is needed to feed to [`scipy.integrate.solve_ivp`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.solve_ivp.html),
        which requires a 1-d array for its `y0` input.
        &#34;&#34;&#34;
        return self.state_mat.T.flatten()  # TODO: change to ravel, to return view when possible

    # @property
    def state_mat_full(self):
        &#34;&#34;&#34;Return full state matrix: (`Vortons.G`, `Vortons.x`, `Vortons.y`) as 3 columns.&#34;&#34;&#34;
        return np.column_stack((self.G, self.state_mat))

    # seems to return a view into self.G, so ok to be property
    @property
    def G_col(self):
        &#34;&#34;&#34;`Vortons.G` as a column vector.&#34;&#34;&#34;
        return self.G[:, np.newaxis]

    @property
    def x(self):
        &#34;&#34;&#34;Array of $x$ positions (a view into `Vortons.state_mat`).&#34;&#34;&#34;
        # slice indexing should give just a view into `self.state_mat`
        # thus `self.x.base` will return the state mat
        # i.e., `vs.x.base is vs.state_mat`
        return self.state_mat[:,0]

    @property
    def y(self):
        &#34;&#34;&#34;Array of $y$ positions (a view into `Vortons.state_mat`).&#34;&#34;&#34;
        return self.state_mat[:,1]

    @property
    def n(self):
        &#34;&#34;&#34;Number of vortons.&#34;&#34;&#34;
        # numpy.ndarray size lookups are esentially free
        return self.G.size  # will have to change if want to allow single G at some point

    def __repr__(self):
        # n_vortons shouldn&#39;t be too many, so let&#39;s show all
        s_vorts = &#34;\n&#34;.join(f&#34;  {v}&#34; for v in self._vortons)
        return f&#34;Vortons(\n{s_vorts}\n)&#34;
        # TODO: should this call `self._update_vortons`? so as to not be out-of-date if state changes?

    def _update_vortons(self):
        self._vortons = [Vorton(G, x, y) for G, x, y in self.state_mat_full()]


    def C(self):
        r&#34;&#34;&#34;Calculate $C$.

        $$
        C = \sum_{\alpha, \beta = 1; \alpha \neq \beta}^{N}
            \Gamma_{\alpha} \Gamma_{\beta} l_{\alpha \beta}^{2}
        $$

        $C$ is supposed to be a conserved quantity in this system.
        -- Chamecki (2005) eq. 15, which references Aref (1979)
        &#34;&#34;&#34;
        n_vortons = self.n
        G = self.G
        C = 0
        for i, j in zip(*np.triu_indices(n_vortons, 1)):  # all combinations without repetition

            xi, yi = self.x[i], self.y[i]
            xj, yj = self.x[j], self.y[j]

            lij_sqd = (xi-xj)**2 + (yi-yj)**2

            Gi, Gj = G[i], G[j]

            C += Gi * Gj * lij_sqd

        return C


    def H(self):
        r&#34;&#34;&#34;Calculate $H$, the Hamiltonian of the system.

        $$
        H = -\frac{1}{4 \pi} \sum_{\alpha, \beta = 1; \alpha \neq \beta}^{N}
            \Gamma_{\alpha} \Gamma_{\beta}
            \ln | r_{\alpha} - r_{\beta} |
        $$
        &#34;&#34;&#34;
        nv = self.n
        G = self.G
        r = self.state_mat  # vorton positions
        H = 0
        for a, b in zip(*np.triu_indices(nv, 1)):
            ra, rb = r[a], r[b]
            Ga, Gb = G[a], G[b]
            H += -1/(4*np.pi) * Ga * Gb * np.log(np.linalg.norm(ra - rb))

        return H


    def I(self):
        r&#34;&#34;&#34;Calculate $I$, the angular impulse of the system.

        $$
        I = \sum_{\alpha = 1}^{N} \Gamma_{\alpha} | r_{\alpha} |^2
        $$
        &#34;&#34;&#34;
        G = self.G
        # r = self.state_mat
        x = self.x
        y = self.y

        # r_hat_sqd =

        return (G * (x**2 + y**2)).sum()


    # TODO: P and Q (coordinates of the center-of-vorticity)


    # TODO: results are not right for equi tri... need to check formulas
    def theta(self):
        r&#34;&#34;&#34;Calculate $\theta$, the action angles??

        Chamecki eq. 19
        &#34;&#34;&#34;
        N = self.n
        I = self.I()
        H = self.H()

        return (2/(N-1))**(N*(N-1)/2) * I**(N*(N-1)) * np.exp(4*np.pi*H)


    def plot(self):
        &#34;&#34;&#34;Plot the vortons.
        (Only their current positions, which are all `Vortons` knows about.)
        &#34;&#34;&#34;
        import matplotlib.pyplot as plt

        fig, ax = plt.subplots()

        # plot vorton positions
        c_Gp = &#34;cadetblue&#34;
        c_Gm = &#34;salmon&#34;
        G = self.G
        Gp, Gm = G &gt; 0, G &lt; 0
        x, y = self.x, self.y
        ax.plot(x[Gp], y[Gp], &#34;o&#34;, ms=7, c=c_Gp, label=r&#34;$\Gamma &gt; 0$&#34;)
        ax.plot(x[Gm], y[Gm], &#34;o&#34;, ms=7, c=c_Gm, label=r&#34;$\Gamma &lt; 0$&#34;)

        # plot center of mass
        x_cm, y_cm = self.cm()
        s_cm = f&#34;({x_cm:.4g}, {y_cm:.4g})&#34;
        ax.plot(x_cm, y_cm, &#34;*&#34;, ms=13, c=&#34;gold&#34;, label=f&#34;center of mass\n{s_cm}&#34;)

        # 2nd mom
        x_cm2, y_cm2 = self.mom(2)
        s_cm2 = f&#34;({x_cm2:.4g}, {y_cm2:.4g})&#34;
        ax.plot(x_cm2, y_cm2, &#34;*&#34;, ms=13, c=&#34;0.4&#34;, label=f&#34;mom2\n{s_cm2}&#34;)

        # 3nd mom
        # TODO: helper fn to DRY this
        x_cm3, y_cm3 = self.mom(3)
        s_cm3 = f&#34;({x_cm3:.4g}, {y_cm3:.4g})&#34;
        ax.plot(x_cm3, y_cm3, &#34;*&#34;, ms=13, c=&#34;0.55&#34;, label=f&#34;mom3\n{s_cm3}&#34;)

        ax.set(
            title=f&#34;$C = {self.C():.4g}$&#34;,
            xlabel=&#34;$x$&#34;,
            ylabel=&#34;$y$&#34;,
        )
        ax.set_aspect(&#34;equal&#34;, &#34;datalim&#34;)
        fig.legend()
        ax.grid(True)
        fig.tight_layout()

        # return


    def mom(self, n, *, abs_G=False, center=False):
        r&#34;&#34;&#34;Compute `n`-th moment.

        Parameters
        ----------
        n : int
            Which [moment](https://en.wikipedia.org/wiki/Moment_(mathematics)) to calculate.
        abs_G : bool
            Whether to take the absolute value of the $\Gamma$ values (false by default).
        center : bool
            `True`: evaluate moment wrt. center of mass from `Vortons.cm`

            `False`: evaluate moment wrt. $(0, 0)$
        &#34;&#34;&#34;
        # seems like a moment but that might not be the correct terminology...
        G = self.G_col
        if abs_G:
            G = np.abs(G)
        G_tot = G.sum()

        x = self.state_mat  # x, y (columns)

        c = self.cm() if center else 0

        x_mom = (G * (x-c)**n).sum(axis=0) / G_tot  # sum along vortons dim, giving a position
        # ^ maybe this should be x - x_cm here...

        return x_mom


    # Chamecki notes suggest this should be called &#34;center of vorticity&#34; or &#34;linear impulse&#34;
    def center_of_mass(self):
        r&#34;&#34;&#34;Compute [center of mass](https://en.wikipedia.org/wiki/Center_of_mass#A_system_of_particles)
        using $\Gamma$ (`Vortons.G`) as mass.
        Equivalent to `Vortons.mom` with `n=1`, `abs_G=True` (currently), `center=False`.
        &#34;&#34;&#34;
        # TODO: what impact should sign of G have on cm? mass is always pos. but G can be neg.
        return self.mom(1, abs_G=True, center=False)

    def cm(self):
        &#34;&#34;&#34;Alias for `Vortons.center_of_mass`.&#34;&#34;&#34;
        return self.center_of_mass()

    def center_coords(self, inplace=False):
        &#34;&#34;&#34;Make $(0, 0)$ the center of mass.&#34;&#34;&#34;
        xy_cm = self.cm()
        x_cm, y_cm = xy_cm
        if not inplace:
            return Vortons(self.G, self.x-x_cm, self.y-y_cm)
        else:
            self.state_mat -= x_cm


    @staticmethod
    def regular_polygon(n, *, G=None, **kwargs):  # TODO: this and the below should be made classmethod since they return class instance
        r&#34;&#34;&#34;Create Vortons with positions corresponding to regular polygon.

        Parameters
        ----------
        n : int
            Polygon order.
        G : int, array-like, optional
            $\Gamma$ value(s) to use.

            Single value or array of values

            default: 1.0

        `**kwargs` are passed on to `regular_polygon_vertices`.
        &#34;&#34;&#34;
        if G is None:
            G = 1.0  # default
        G = np.asarray(G)
        if G.size == 1:  # single G provided, or using the default
            G = np.full((n,), G)  # TODO: could also the constructor to accept single G
        if G.size != n:
            raise ValueError(f&#34;`G` must have size `n` or 1, but is {G.size!r}&#34;)

        xy = regular_polygon_vertices(n, **kwargs).T  # x, y cols-&gt; rows (for unpacking)

        return Vortons(G, *xy)


    @staticmethod
    def isos_triangle(*, G=None, **kwargs):
        &#34;&#34;&#34;Create Vortons with isosceles triangle vertices.

        `**kwargs` are passed on to `isos_triangle_vertices`.
        &#34;&#34;&#34;
        G = _maybe_fill_G(G, 3)

        xy = isos_triangle_vertices(**kwargs).T

        return Vortons(G, *xy)


    def maybe_with_tracers(self, tracers: Tracers = None):
        &#34;&#34;&#34;Return new `Vortons` with the tracers (maybe) included.

        .. caution::
           Temporary? hack to get full (combined) `state_vec` for the whole system.

        If `Tracers` is `None`, just returns `self`.
        &#34;&#34;&#34;
        if tracers is None:
            return self

        # TODO: add option to extend existing Vortons instead of creating a new. `inplace`?

        G_v = self.G
        xy_v = self.state_mat
        xy_t = tracers.state_mat
        G_t = np.zeros((tracers.n,))

        G = np.append(G_v, G_t)
        x, y = np.append(xy_v, xy_t, axis=0).T  # unpacking arrays goes by rows

        return Vortons(G, x, y)

    # TODO: indexing dunder methods

    # TODO: overload addition and such

    # TODO: class method to take List[Vorton] and return a Vortons?




def points_randn():  # TODO
    raise NotImplementedError


def points_randu(n, *, c=(0, 0), dx=2, dy=2):
    &#34;&#34;&#34;Sample from 2-d uniform.

    Parameters
    ----------
    n : int
        Number of points.
    c : array_like
        Coordinates of the center ($x_c$, $y_c$).
    dx, dy : float
        $x$ positions will be sampled from $[$`-dx`, `dx`$)$, and $y$ similarly.
    &#34;&#34;&#34;
    c = np.asarray(c)
    x = np.random.uniform(-dx, dx, (n,))
    y = np.random.uniform(-dy, dy, (n,))
    return np.column_stack((x, y)) + c


def points_spiral(n, *, c=(0, 0), rmin=0, rmax=2, revs=3):
    &#34;&#34;&#34;Create spiral of points.

    Parameters
    ----------
    n : int
        Number of points.
    c : array_like
        Coordinates of the center ($x_c$, $y_c$).
    rmin : float
        Minimum radius (distance from the center for the innermost point).
    rmax : float
        Maximum radius (distance from the center for the outermost point).
    revs : float
        Total number of revolutions in the spiral.
    &#34;&#34;&#34;
    c = np.asarray(c)

    rad = np.linspace(rmin, rmax, n)  # radius

    deg_tot = revs*360
    rotmat = rotmat_2d(deg_tot/n)
    rhat = np.full((n, 2), (0, 1), dtype=float)  # rhat: unit vectors
    for i in range(1, n):
        rhat[i, :] = rotate_2d(rhat[i-1, :], rotmat=rotmat)
    # TODO: here would be simpler to do polar coords first then convert to x,y

    return rad[:, np.newaxis] * rhat + c


def points_grid():  # TODO
    raise NotImplementedError


def _maybe_fill_G(G, n):
    if G is None:  # this first part maybe shouldn&#39;t be here? or kwarg for default G val?
        G = 1.0
    G = np.asarray(G)
    if G.size == 1:  # single G provided, or using the default
        G = np.full((n,), G)  # TODO: could also the constructor to accept single G
    if G.size != n:
        raise ValueError(f&#34;`G` must have size `n` or 1, but is {G.size!r}&#34;)

    return G


def rotmat_2d(ang_deg):  # TODO: could lru_cache?
    &#34;&#34;&#34;Return rotation matrix for rotation `ang_deg` in degrees.
    For left-multiplication of a column position vector.

    .. note::
       [`scipy.spatial.transform.Rotation`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.transform.Rotation.html)
       can be used for 3-d rotations.
    &#34;&#34;&#34;
    ang = np.deg2rad(ang_deg)
    c, s = np.cos(ang), np.sin(ang)
    R = np.array([
        [c, -s],
        [s, c]
    ])
    return R


def rotate_2d(x, *, ang_deg=None, rotmat=None):
    r&#34;&#34;&#34;Rotate vector `x` by `ang_deg` degrees.

    .. important::
       Either `ang_deg` or `rotmat` can be provided to specify the degree of rotation, but not both.

       If `ang_deg` is used, the rotation matrix will be computed with `rotmat_2d`, so
       you can pass `rotmat` instead to avoid computing it multiple times.

    Parameters
    ----------
    x : array_like
        The vector to be rotated.
    ang_deg : int, float
        Degrees by which to rotate `x` about the origin.

        positive $\to$ counter-clockwise rotation
    rotmat : array_like
        shape: `(2, 2)`

        Rotation matrix -- left-multiplies a column position vector to give rotated position.

    &#34;&#34;&#34;
    x = np.asarray(x)
    if ang_deg and rotmat:
        raise Exception(&#34;Only one of `ang_deg` and `rotmat` should be specified.&#34;)

    assert x.ndim == 1  # need a true vector

    if ang_deg:
        rotmat = rotmat_2d(ang_deg)
    else:
        if rotmat is None:
            raise Exception(&#34;If `ang_deg` is not provided, `rotmat` must be.&#34;)

    return (rotmat @ x[:, np.newaxis]).squeeze()


def regular_polygon_vertices(n, *, c=(0, 0), r_c=1):
    &#34;&#34;&#34;Regular polygon vertices.

    Parameters
    ----------
    n : int
        Polygon order (number of sides/vertices).
    c : array_like
        Coordinates of the center of the inscribing circle ($x_c$, $y_c$).
    r_c : float, int
        Radius $r_c$ of the inscribing circle.
    &#34;&#34;&#34;
    c = np.asarray(c)

    # initial vertex
    vert0 = np.r_[0, r_c]

    # rotation matrix -- left-multiplies a column position vector to give rotated position
    rotmat = rotmat_2d(360/n)

    verts = np.full((n, 2), vert0, dtype=float)
    # successive rotations
    for i in range(1, n):
        verts[i, :] = rotate_2d(verts[i-1, :], rotmat=rotmat)

    return verts + c


def isos_triangle_vertices(*, theta_deg=None, Lambda=None):
    r&#34;&#34;&#34;Isosceles triangle vertices.
    With fixed top point $(0, 1)$ and fixed left &amp; right $y=-0.5$.

    .. important::
       Either `theta_deg` or `Lambda` can be used to specify the angle, but not both.

    Parameters
    ----------
    theta_deg : float
        Value of the two angles $\theta$ between the horizontal base and connections to the top point at $(0,1)$
        in degrees.

        $\theta = 72^{\circ} \to \Lambda_c$ (equal to $1/\sqrt{2}$)

        $\theta = 60^{\circ} \to$ equilateral triangle (can also create with `regular_polygon_vertices`,
        which gives control over size and location)

    Lambda : float
        $\Lambda \in (0, 1]$. Related to $\theta$ by $\theta = \pi / (\Lambda^2 + 2)$

        $\Lambda = 1 \to$ equilateral triangle

    &#34;&#34;&#34;
    if (theta_deg is not None and Lambda is not None) or (theta_deg is None and Lambda is None):
        raise Exception(&#34;Specify either `theta_deg` or `Lambda` (not both).&#34;)

    if Lambda:
        assert Lambda &gt; 0 and Lambda &lt;= 1
        theta_deg = 180 / (Lambda**2 + 2)

    theta = np.deg2rad(theta_deg)

    xb = 1.5/np.tan(theta)  # one half of x base

    xi = [-xb,  0,  xb]
    yi = [-0.5, 1, -0.5]

    Lambda = np.sqrt( (180-2*theta_deg) / float(theta_deg) )  # Marcelo eqns 17--19

    return np.column_stack((xi, yi))


if __name__ == &#34;__main__&#34;:
    import matplotlib.pyplot as plt

    plt.close(&#34;all&#34;)

    vs = Vortons([1, 1], [0, 1], [0, 0])
    vs.plot()

    # G sum here is 0, messing up the mom&#39;s...
    Vortons([1, -1], [0, 1], [0, 0]).plot()

    Vortons.regular_polygon(3).plot()

    Vortons.regular_polygon(10, c=(1, 0), r_c=0.5).plot()

    Vortons.isos_triangle(theta_deg=72).plot()

    Vortons.isos_triangle(Lambda=0.49).plot()

    ts = Tracers.randu(50)

    Tracers.spiral(100).plot()

    Tracers.spiral(200, c=(1, 0), revs=10).plot(connect=True)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="vorts.vortons.isos_triangle_vertices"><code class="name flex">
<span>def <span class="ident">isos_triangle_vertices</span></span>(<span>*, theta_deg=None, Lambda=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Isosceles triangle vertices.
With fixed top point $(0, 1)$ and fixed left &amp; right $y=-0.5$.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Either <code>theta_deg</code> or <code>Lambda</code> can be used to specify the angle, but not both.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>theta_deg</code></strong> :&ensp;<code>float</code></dt>
<dd>
<p>Value of the two angles $\theta$ between the horizontal base and connections to the top point at $(0,1)$
in degrees.</p>
<p>$\theta = 72^{\circ} \to \Lambda_c$ (equal to $1/\sqrt{2}$)</p>
<p>$\theta = 60^{\circ} \to$ equilateral triangle (can also create with <code><a title="vorts.vortons.regular_polygon_vertices" href="#vorts.vortons.regular_polygon_vertices">regular_polygon_vertices()</a></code>,
which gives control over size and location)</p>
</dd>
<dt><strong><code>Lambda</code></strong> :&ensp;<code>float</code></dt>
<dd>
<p>$\Lambda \in (0, 1]$. Related to $\theta$ by $\theta = \pi / (\Lambda^2 + 2)$</p>
<p>$\Lambda = 1 \to$ equilateral triangle</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/zmoon/vorts/blob/72f11de365abad6b6dc355c92609ad20e8ead8ce/vorts\vortons.py#L617-L657" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def isos_triangle_vertices(*, theta_deg=None, Lambda=None):
    r&#34;&#34;&#34;Isosceles triangle vertices.
    With fixed top point $(0, 1)$ and fixed left &amp; right $y=-0.5$.

    .. important::
       Either `theta_deg` or `Lambda` can be used to specify the angle, but not both.

    Parameters
    ----------
    theta_deg : float
        Value of the two angles $\theta$ between the horizontal base and connections to the top point at $(0,1)$
        in degrees.

        $\theta = 72^{\circ} \to \Lambda_c$ (equal to $1/\sqrt{2}$)

        $\theta = 60^{\circ} \to$ equilateral triangle (can also create with `regular_polygon_vertices`,
        which gives control over size and location)

    Lambda : float
        $\Lambda \in (0, 1]$. Related to $\theta$ by $\theta = \pi / (\Lambda^2 + 2)$

        $\Lambda = 1 \to$ equilateral triangle

    &#34;&#34;&#34;
    if (theta_deg is not None and Lambda is not None) or (theta_deg is None and Lambda is None):
        raise Exception(&#34;Specify either `theta_deg` or `Lambda` (not both).&#34;)

    if Lambda:
        assert Lambda &gt; 0 and Lambda &lt;= 1
        theta_deg = 180 / (Lambda**2 + 2)

    theta = np.deg2rad(theta_deg)

    xb = 1.5/np.tan(theta)  # one half of x base

    xi = [-xb,  0,  xb]
    yi = [-0.5, 1, -0.5]

    Lambda = np.sqrt( (180-2*theta_deg) / float(theta_deg) )  # Marcelo eqns 17--19

    return np.column_stack((xi, yi))</code></pre>
</details>
</dd>
<dt id="vorts.vortons.points_grid"><code class="name flex">
<span>def <span class="ident">points_grid</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/zmoon/vorts/blob/72f11de365abad6b6dc355c92609ad20e8ead8ce/vorts\vortons.py#L518-L519" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def points_grid():  # TODO
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="vorts.vortons.points_randn"><code class="name flex">
<span>def <span class="ident">points_randn</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/zmoon/vorts/blob/72f11de365abad6b6dc355c92609ad20e8ead8ce/vorts\vortons.py#L466-L467" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def points_randn():  # TODO
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="vorts.vortons.points_randu"><code class="name flex">
<span>def <span class="ident">points_randu</span></span>(<span>n, *, c=(0, 0), dx=2, dy=2)</span>
</code></dt>
<dd>
<div class="desc"><p>Sample from 2-d uniform.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of points.</dd>
<dt><strong><code>c</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Coordinates of the center ($x_c$, $y_c$).</dd>
<dt><strong><code>dx</code></strong>, <strong><code>dy</code></strong> :&ensp;<code>float</code></dt>
<dd>$x$ positions will be sampled from $[$<code>-dx</code>, <code>dx</code>$)$, and $y$ similarly.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/zmoon/vorts/blob/72f11de365abad6b6dc355c92609ad20e8ead8ce/vorts\vortons.py#L470-L485" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def points_randu(n, *, c=(0, 0), dx=2, dy=2):
    &#34;&#34;&#34;Sample from 2-d uniform.

    Parameters
    ----------
    n : int
        Number of points.
    c : array_like
        Coordinates of the center ($x_c$, $y_c$).
    dx, dy : float
        $x$ positions will be sampled from $[$`-dx`, `dx`$)$, and $y$ similarly.
    &#34;&#34;&#34;
    c = np.asarray(c)
    x = np.random.uniform(-dx, dx, (n,))
    y = np.random.uniform(-dy, dy, (n,))
    return np.column_stack((x, y)) + c</code></pre>
</details>
</dd>
<dt id="vorts.vortons.points_spiral"><code class="name flex">
<span>def <span class="ident">points_spiral</span></span>(<span>n, *, c=(0, 0), rmin=0, rmax=2, revs=3)</span>
</code></dt>
<dd>
<div class="desc"><p>Create spiral of points.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of points.</dd>
<dt><strong><code>c</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Coordinates of the center ($x_c$, $y_c$).</dd>
<dt><strong><code>rmin</code></strong> :&ensp;<code>float</code></dt>
<dd>Minimum radius (distance from the center for the innermost point).</dd>
<dt><strong><code>rmax</code></strong> :&ensp;<code>float</code></dt>
<dd>Maximum radius (distance from the center for the outermost point).</dd>
<dt><strong><code>revs</code></strong> :&ensp;<code>float</code></dt>
<dd>Total number of revolutions in the spiral.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/zmoon/vorts/blob/72f11de365abad6b6dc355c92609ad20e8ead8ce/vorts\vortons.py#L488-L515" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def points_spiral(n, *, c=(0, 0), rmin=0, rmax=2, revs=3):
    &#34;&#34;&#34;Create spiral of points.

    Parameters
    ----------
    n : int
        Number of points.
    c : array_like
        Coordinates of the center ($x_c$, $y_c$).
    rmin : float
        Minimum radius (distance from the center for the innermost point).
    rmax : float
        Maximum radius (distance from the center for the outermost point).
    revs : float
        Total number of revolutions in the spiral.
    &#34;&#34;&#34;
    c = np.asarray(c)

    rad = np.linspace(rmin, rmax, n)  # radius

    deg_tot = revs*360
    rotmat = rotmat_2d(deg_tot/n)
    rhat = np.full((n, 2), (0, 1), dtype=float)  # rhat: unit vectors
    for i in range(1, n):
        rhat[i, :] = rotate_2d(rhat[i-1, :], rotmat=rotmat)
    # TODO: here would be simpler to do polar coords first then convert to x,y

    return rad[:, np.newaxis] * rhat + c</code></pre>
</details>
</dd>
<dt id="vorts.vortons.regular_polygon_vertices"><code class="name flex">
<span>def <span class="ident">regular_polygon_vertices</span></span>(<span>n, *, c=(0, 0), r_c=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Regular polygon vertices.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code></dt>
<dd>Polygon order (number of sides/vertices).</dd>
<dt><strong><code>c</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Coordinates of the center of the inscribing circle ($x_c$, $y_c$).</dd>
<dt><strong><code>r_c</code></strong> :&ensp;<code>float, int</code></dt>
<dd>Radius $r_c$ of the inscribing circle.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/zmoon/vorts/blob/72f11de365abad6b6dc355c92609ad20e8ead8ce/vorts\vortons.py#L589-L614" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def regular_polygon_vertices(n, *, c=(0, 0), r_c=1):
    &#34;&#34;&#34;Regular polygon vertices.

    Parameters
    ----------
    n : int
        Polygon order (number of sides/vertices).
    c : array_like
        Coordinates of the center of the inscribing circle ($x_c$, $y_c$).
    r_c : float, int
        Radius $r_c$ of the inscribing circle.
    &#34;&#34;&#34;
    c = np.asarray(c)

    # initial vertex
    vert0 = np.r_[0, r_c]

    # rotation matrix -- left-multiplies a column position vector to give rotated position
    rotmat = rotmat_2d(360/n)

    verts = np.full((n, 2), vert0, dtype=float)
    # successive rotations
    for i in range(1, n):
        verts[i, :] = rotate_2d(verts[i-1, :], rotmat=rotmat)

    return verts + c</code></pre>
</details>
</dd>
<dt id="vorts.vortons.rotate_2d"><code class="name flex">
<span>def <span class="ident">rotate_2d</span></span>(<span>x, *, ang_deg=None, rotmat=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Rotate vector <code>x</code> by <code>ang_deg</code> degrees.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Either <code>ang_deg</code> or <code>rotmat</code> can be provided to specify the degree of rotation, but not both.</p>
<p>If <code>ang_deg</code> is used, the rotation matrix will be computed with <code><a title="vorts.vortons.rotmat_2d" href="#vorts.vortons.rotmat_2d">rotmat_2d()</a></code>, so
you can pass <code>rotmat</code> instead to avoid computing it multiple times.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>array_like</code></dt>
<dd>The vector to be rotated.</dd>
<dt><strong><code>ang_deg</code></strong> :&ensp;<code>int, float</code></dt>
<dd>
<p>Degrees by which to rotate <code>x</code> about the origin.</p>
<p>positive $\to$ counter-clockwise rotation</p>
</dd>
<dt><strong><code>rotmat</code></strong> :&ensp;<code>array_like</code></dt>
<dd>
<p>shape: <code>(2, 2)</code></p>
<p>Rotation matrix &ndash; left-multiplies a column position vector to give rotated position.</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/zmoon/vorts/blob/72f11de365abad6b6dc355c92609ad20e8ead8ce/vorts\vortons.py#L551-L586" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def rotate_2d(x, *, ang_deg=None, rotmat=None):
    r&#34;&#34;&#34;Rotate vector `x` by `ang_deg` degrees.

    .. important::
       Either `ang_deg` or `rotmat` can be provided to specify the degree of rotation, but not both.

       If `ang_deg` is used, the rotation matrix will be computed with `rotmat_2d`, so
       you can pass `rotmat` instead to avoid computing it multiple times.

    Parameters
    ----------
    x : array_like
        The vector to be rotated.
    ang_deg : int, float
        Degrees by which to rotate `x` about the origin.

        positive $\to$ counter-clockwise rotation
    rotmat : array_like
        shape: `(2, 2)`

        Rotation matrix -- left-multiplies a column position vector to give rotated position.

    &#34;&#34;&#34;
    x = np.asarray(x)
    if ang_deg and rotmat:
        raise Exception(&#34;Only one of `ang_deg` and `rotmat` should be specified.&#34;)

    assert x.ndim == 1  # need a true vector

    if ang_deg:
        rotmat = rotmat_2d(ang_deg)
    else:
        if rotmat is None:
            raise Exception(&#34;If `ang_deg` is not provided, `rotmat` must be.&#34;)

    return (rotmat @ x[:, np.newaxis]).squeeze()</code></pre>
</details>
</dd>
<dt id="vorts.vortons.rotmat_2d"><code class="name flex">
<span>def <span class="ident">rotmat_2d</span></span>(<span>ang_deg)</span>
</code></dt>
<dd>
<div class="desc"><p>Return rotation matrix for rotation <code>ang_deg</code> in degrees.
For left-multiplication of a column position vector.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.transform.Rotation.html"><code>scipy.spatial.transform.Rotation</code></a>
can be used for 3-d rotations.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/zmoon/vorts/blob/72f11de365abad6b6dc355c92609ad20e8ead8ce/vorts\vortons.py#L534-L548" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def rotmat_2d(ang_deg):  # TODO: could lru_cache?
    &#34;&#34;&#34;Return rotation matrix for rotation `ang_deg` in degrees.
    For left-multiplication of a column position vector.

    .. note::
       [`scipy.spatial.transform.Rotation`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.transform.Rotation.html)
       can be used for 3-d rotations.
    &#34;&#34;&#34;
    ang = np.deg2rad(ang_deg)
    c, s = np.cos(ang), np.sin(ang)
    R = np.array([
        [c, -s],
        [s, c]
    ])
    return R</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="vorts.vortons.Tracer"><code class="flex name class">
<span>class <span class="ident">Tracer</span></span>
<span>(</span><span>x: float, y: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Tracer &ndash; a vorton with $\Gamma=0$ (no circulation/mass) that knows its current position.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/zmoon/vorts/blob/72f11de365abad6b6dc355c92609ad20e8ead8ce/vorts\vortons.py#L27-L32" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Tracer(NamedTuple):
    r&#34;&#34;&#34;Tracer -- a vorton with $\Gamma=0$ (no circulation/mass) that knows its current position.&#34;&#34;&#34;
    x: float
    &#34;&#34;&#34;$x$ position&#34;&#34;&#34;
    y: float
    &#34;&#34;&#34;$y$ position&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="vorts.vortons.Tracer.x"><code class="name">var <span class="ident">x</span> : float</code></dt>
<dd>
<div class="desc"><p>$x$ position</p></div>
</dd>
<dt id="vorts.vortons.Tracer.y"><code class="name">var <span class="ident">y</span> : float</code></dt>
<dd>
<div class="desc"><p>$y$ position</p></div>
</dd>
</dl>
</dd>
<dt id="vorts.vortons.Tracers"><code class="flex name class">
<span>class <span class="ident">Tracers</span></span>
<span>(</span><span>x, y)</span>
</code></dt>
<dd>
<div class="desc"><p>Collection of <code><a title="vorts.vortons.Tracer" href="#vorts.vortons.Tracer">Tracer</a></code>s.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong>, <strong><code>y</code></strong> :&ensp;<code>array_like</code></dt>
<dd>
<p>shape: <code>(n_vortons,)</code></p>
<p>Tracer initial $x$ and $y$ positions.</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/zmoon/vorts/blob/72f11de365abad6b6dc355c92609ad20e8ead8ce/vorts\vortons.py#L40-L111" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Tracers:
    &#34;&#34;&#34;Collection of `Tracer`s.&#34;&#34;&#34;
    def __init__(self, x, y):
        &#34;&#34;&#34;
        Parameters
        ----------
        x, y : array_like
            shape: `(n_vortons,)`

            Tracer initial $x$ and $y$ positions.
        &#34;&#34;&#34;
        x = np.asarray(x, dtype=float)
        y = np.asarray(y, dtype=float)

        assert x.shape == y.shape and x.ndim == 1

        self.state_mat = np.column_stack((x, y))


    def __repr__(self):
        # unlike Vortons, might have many tracers
        # so don&#39;t need to show all in the repr
        n = self.n
        return f&#34;Tracers(n={n})&#34;

    @property
    def n(self):
        return self.state_mat.shape[0]

    @property
    def x(self):
        return self.state_mat[:,0]

    @property
    def y(self):
        return self.state_mat[:,1]

    def state_vec(self):
        return self.state_mat.T.flatten()

    def state_mat_full(self):
        &#34;&#34;&#34;Full state mat for tracers doesn&#39;t include G.&#34;&#34;&#34;
        warnings.warn(&#34;Note that `state_mat_full` for tracers is the same as `state_mat` (no G).&#34;)
        return self.state_mat

    @staticmethod
    def randu(n, **kwargs):
        xy = points_randu(n, **kwargs).T
        return Tracers(*xy)

    @staticmethod
    def spiral(n, **kwargs):
        xy = points_spiral(n, **kwargs).T
        return Tracers(*xy)

    def plot(self, *, connect=False):
        import matplotlib.pyplot as plt

        fig, ax = plt.subplots()

        x, y = self.x, self.y
        fmt = &#34;-o&#34; if connect else &#34;o&#34;
        ax.plot(x, y, fmt, c=&#34;0.5&#34;, ms=4, label=&#34;tracers&#34;)

        ax.set(
            xlabel=&#34;$x$&#34;,
            ylabel=&#34;$y$&#34;,
        )
        ax.set_aspect(&#34;equal&#34;, &#34;box&#34;)
        fig.legend()
        ax.grid(True)
        fig.tight_layout()</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="vorts.vortons.Tracers.randu"><code class="name flex">
<span>def <span class="ident">randu</span></span>(<span>n, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/zmoon/vorts/blob/72f11de365abad6b6dc355c92609ad20e8ead8ce/vorts\vortons.py#L85-L88" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def randu(n, **kwargs):
    xy = points_randu(n, **kwargs).T
    return Tracers(*xy)</code></pre>
</details>
</dd>
<dt id="vorts.vortons.Tracers.spiral"><code class="name flex">
<span>def <span class="ident">spiral</span></span>(<span>n, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/zmoon/vorts/blob/72f11de365abad6b6dc355c92609ad20e8ead8ce/vorts\vortons.py#L90-L93" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def spiral(n, **kwargs):
    xy = points_spiral(n, **kwargs).T
    return Tracers(*xy)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="vorts.vortons.Tracers.n"><code class="name">var <span class="ident">n</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/zmoon/vorts/blob/72f11de365abad6b6dc355c92609ad20e8ead8ce/vorts\vortons.py#L65-L67" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def n(self):
    return self.state_mat.shape[0]</code></pre>
</details>
</dd>
<dt id="vorts.vortons.Tracers.x"><code class="name">var <span class="ident">x</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/zmoon/vorts/blob/72f11de365abad6b6dc355c92609ad20e8ead8ce/vorts\vortons.py#L69-L71" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def x(self):
    return self.state_mat[:,0]</code></pre>
</details>
</dd>
<dt id="vorts.vortons.Tracers.y"><code class="name">var <span class="ident">y</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/zmoon/vorts/blob/72f11de365abad6b6dc355c92609ad20e8ead8ce/vorts\vortons.py#L73-L75" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def y(self):
    return self.state_mat[:,1]</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="vorts.vortons.Tracers.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, *, connect=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/zmoon/vorts/blob/72f11de365abad6b6dc355c92609ad20e8ead8ce/vorts\vortons.py#L95-L111" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def plot(self, *, connect=False):
    import matplotlib.pyplot as plt

    fig, ax = plt.subplots()

    x, y = self.x, self.y
    fmt = &#34;-o&#34; if connect else &#34;o&#34;
    ax.plot(x, y, fmt, c=&#34;0.5&#34;, ms=4, label=&#34;tracers&#34;)

    ax.set(
        xlabel=&#34;$x$&#34;,
        ylabel=&#34;$y$&#34;,
    )
    ax.set_aspect(&#34;equal&#34;, &#34;box&#34;)
    fig.legend()
    ax.grid(True)
    fig.tight_layout()</code></pre>
</details>
</dd>
<dt id="vorts.vortons.Tracers.state_mat_full"><code class="name flex">
<span>def <span class="ident">state_mat_full</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Full state mat for tracers doesn't include G.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/zmoon/vorts/blob/72f11de365abad6b6dc355c92609ad20e8ead8ce/vorts\vortons.py#L80-L83" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def state_mat_full(self):
    &#34;&#34;&#34;Full state mat for tracers doesn&#39;t include G.&#34;&#34;&#34;
    warnings.warn(&#34;Note that `state_mat_full` for tracers is the same as `state_mat` (no G).&#34;)
    return self.state_mat</code></pre>
</details>
</dd>
<dt id="vorts.vortons.Tracers.state_vec"><code class="name flex">
<span>def <span class="ident">state_vec</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/zmoon/vorts/blob/72f11de365abad6b6dc355c92609ad20e8ead8ce/vorts\vortons.py#L77-L78" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def state_vec(self):
    return self.state_mat.T.flatten()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="vorts.vortons.Vorton"><code class="flex name class">
<span>class <span class="ident">Vorton</span></span>
<span>(</span><span>G: float, x: float, y: float)</span>
</code></dt>
<dd>
<div class="desc"><p>A vorton that knows its current state (position and strength).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/zmoon/vorts/blob/72f11de365abad6b6dc355c92609ad20e8ead8ce/vorts\vortons.py#L12-L24" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Vorton(NamedTuple):
    &#34;&#34;&#34;A vorton that knows its current state (position and strength).&#34;&#34;&#34;
    G: float
    r&#34;&#34;&#34;$\Gamma$, the strength of the circulation, with sign to indicate direction.

    See also
    --------
    Vortons : For a more detailed description.
    &#34;&#34;&#34;
    x: float
    &#34;&#34;&#34;$x$ position&#34;&#34;&#34;
    y: float
    &#34;&#34;&#34;$y$ position&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="vorts.vortons.Vorton.G"><code class="name">var <span class="ident">G</span> : float</code></dt>
<dd>
<div class="desc"><p>$\Gamma$, the strength of the circulation, with sign to indicate direction.</p>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code><a title="vorts.vortons.Vortons" href="#vorts.vortons.Vortons">Vortons</a></code></dt>
<dd>For a more detailed description.</dd>
</dl></div>
</dd>
<dt id="vorts.vortons.Vorton.x"><code class="name">var <span class="ident">x</span> : float</code></dt>
<dd>
<div class="desc"><p>$x$ position</p></div>
</dd>
<dt id="vorts.vortons.Vorton.y"><code class="name">var <span class="ident">y</span> : float</code></dt>
<dd>
<div class="desc"><p>$y$ position</p></div>
</dd>
</dl>
</dd>
<dt id="vorts.vortons.Vortons"><code class="flex name class">
<span>class <span class="ident">Vortons</span></span>
<span>(</span><span>G, x, y)</span>
</code></dt>
<dd>
<div class="desc"><p>Collection of <code><a title="vorts.vortons.Vorton" href="#vorts.vortons.Vorton">Vorton</a></code>s.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>G</code></strong>, <strong><code>x</code></strong>, <strong><code>y</code></strong> :&ensp;<code>array_like</code></dt>
<dd>
<p>shape: <code>(n_vortons,)</code></p>
<p><code>G</code>: $\Gamma$s ("G" for <a href="https://en.wikipedia.org/wiki/Gamma">Gamma</a>).</p>
<p>$\Gamma$ represents the strength of the circulation, with sign to indicate direction.
In fluid dynamics, circulation $\Gamma$ is the line integral of velocity
or flux of vorticity vectors through a surface (here the $xy$-plane).</p>
<p><code>x</code>: $x$ positions</p>
<p><code>y</code>: $y$ positions</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/zmoon/vorts/blob/72f11de365abad6b6dc355c92609ad20e8ead8ce/vorts\vortons.py#L116-L455" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Vortons:
    &#34;&#34;&#34;Collection of `Vorton`s.&#34;&#34;&#34;
    def __init__(self, G, x, y):
        r&#34;&#34;&#34;

        Parameters
        ----------
        G, x, y : array_like
            shape: `(n_vortons,)`

            `G`: $\Gamma$s (&#34;G&#34; for [Gamma](https://en.wikipedia.org/wiki/Gamma)).

            $\Gamma$ represents the strength of the circulation, with sign to indicate direction.
            In fluid dynamics, circulation $\Gamma$ is the line integral of velocity
            or flux of vorticity vectors through a surface (here the $xy$-plane).

            `x`: $x$ positions

            `y`: $y$ positions

        &#34;&#34;&#34;
        self.G = np.asarray(G)
        r&#34;&#34;&#34;Array of vorton strengths ($\Gamma$).&#34;&#34;&#34;
        if np.any(self.G == 0):
            warnings.warn(
                &#34;Tracers should be in a `Tracers` instance. &#34;
                &#34;The ability to add them here may be removed in the future.&#34;
            )

        # the state matrix has shape (n_vortons, n_pos_dims) (G excluded since time-invariant)
        x = np.asarray(x, dtype=float)
        y = np.asarray(y, dtype=float)
        self.state_mat = np.column_stack((x, y))
        &#34;&#34;&#34;2-d array of $(x, y)$ coordinates -- each row is the coordinate of one vorton.&#34;&#34;&#34;

        assert self.G.ndim == 1 and self.state_mat.shape[1] == 2
        assert self.G.size == self.state_mat.shape[0]  # n_vortons

        # create initial corresponding Vorton objects
        self._update_vortons()


    # these 2 don&#39;t really need to be property?
    # maybe shouldn&#39;t be, to emphasize that state_mat is the real data
    # @property
    def state_vec(self):
        &#34;&#34;&#34;Return flattened state matrix (`Vortons.state_mat`; `Vortons.G` not included).

        If using `vorts.py.integ.integrate_scipy`,
        this is needed to feed to [`scipy.integrate.solve_ivp`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.solve_ivp.html),
        which requires a 1-d array for its `y0` input.
        &#34;&#34;&#34;
        return self.state_mat.T.flatten()  # TODO: change to ravel, to return view when possible

    # @property
    def state_mat_full(self):
        &#34;&#34;&#34;Return full state matrix: (`Vortons.G`, `Vortons.x`, `Vortons.y`) as 3 columns.&#34;&#34;&#34;
        return np.column_stack((self.G, self.state_mat))

    # seems to return a view into self.G, so ok to be property
    @property
    def G_col(self):
        &#34;&#34;&#34;`Vortons.G` as a column vector.&#34;&#34;&#34;
        return self.G[:, np.newaxis]

    @property
    def x(self):
        &#34;&#34;&#34;Array of $x$ positions (a view into `Vortons.state_mat`).&#34;&#34;&#34;
        # slice indexing should give just a view into `self.state_mat`
        # thus `self.x.base` will return the state mat
        # i.e., `vs.x.base is vs.state_mat`
        return self.state_mat[:,0]

    @property
    def y(self):
        &#34;&#34;&#34;Array of $y$ positions (a view into `Vortons.state_mat`).&#34;&#34;&#34;
        return self.state_mat[:,1]

    @property
    def n(self):
        &#34;&#34;&#34;Number of vortons.&#34;&#34;&#34;
        # numpy.ndarray size lookups are esentially free
        return self.G.size  # will have to change if want to allow single G at some point

    def __repr__(self):
        # n_vortons shouldn&#39;t be too many, so let&#39;s show all
        s_vorts = &#34;\n&#34;.join(f&#34;  {v}&#34; for v in self._vortons)
        return f&#34;Vortons(\n{s_vorts}\n)&#34;
        # TODO: should this call `self._update_vortons`? so as to not be out-of-date if state changes?

    def _update_vortons(self):
        self._vortons = [Vorton(G, x, y) for G, x, y in self.state_mat_full()]


    def C(self):
        r&#34;&#34;&#34;Calculate $C$.

        $$
        C = \sum_{\alpha, \beta = 1; \alpha \neq \beta}^{N}
            \Gamma_{\alpha} \Gamma_{\beta} l_{\alpha \beta}^{2}
        $$

        $C$ is supposed to be a conserved quantity in this system.
        -- Chamecki (2005) eq. 15, which references Aref (1979)
        &#34;&#34;&#34;
        n_vortons = self.n
        G = self.G
        C = 0
        for i, j in zip(*np.triu_indices(n_vortons, 1)):  # all combinations without repetition

            xi, yi = self.x[i], self.y[i]
            xj, yj = self.x[j], self.y[j]

            lij_sqd = (xi-xj)**2 + (yi-yj)**2

            Gi, Gj = G[i], G[j]

            C += Gi * Gj * lij_sqd

        return C


    def H(self):
        r&#34;&#34;&#34;Calculate $H$, the Hamiltonian of the system.

        $$
        H = -\frac{1}{4 \pi} \sum_{\alpha, \beta = 1; \alpha \neq \beta}^{N}
            \Gamma_{\alpha} \Gamma_{\beta}
            \ln | r_{\alpha} - r_{\beta} |
        $$
        &#34;&#34;&#34;
        nv = self.n
        G = self.G
        r = self.state_mat  # vorton positions
        H = 0
        for a, b in zip(*np.triu_indices(nv, 1)):
            ra, rb = r[a], r[b]
            Ga, Gb = G[a], G[b]
            H += -1/(4*np.pi) * Ga * Gb * np.log(np.linalg.norm(ra - rb))

        return H


    def I(self):
        r&#34;&#34;&#34;Calculate $I$, the angular impulse of the system.

        $$
        I = \sum_{\alpha = 1}^{N} \Gamma_{\alpha} | r_{\alpha} |^2
        $$
        &#34;&#34;&#34;
        G = self.G
        # r = self.state_mat
        x = self.x
        y = self.y

        # r_hat_sqd =

        return (G * (x**2 + y**2)).sum()


    # TODO: P and Q (coordinates of the center-of-vorticity)


    # TODO: results are not right for equi tri... need to check formulas
    def theta(self):
        r&#34;&#34;&#34;Calculate $\theta$, the action angles??

        Chamecki eq. 19
        &#34;&#34;&#34;
        N = self.n
        I = self.I()
        H = self.H()

        return (2/(N-1))**(N*(N-1)/2) * I**(N*(N-1)) * np.exp(4*np.pi*H)


    def plot(self):
        &#34;&#34;&#34;Plot the vortons.
        (Only their current positions, which are all `Vortons` knows about.)
        &#34;&#34;&#34;
        import matplotlib.pyplot as plt

        fig, ax = plt.subplots()

        # plot vorton positions
        c_Gp = &#34;cadetblue&#34;
        c_Gm = &#34;salmon&#34;
        G = self.G
        Gp, Gm = G &gt; 0, G &lt; 0
        x, y = self.x, self.y
        ax.plot(x[Gp], y[Gp], &#34;o&#34;, ms=7, c=c_Gp, label=r&#34;$\Gamma &gt; 0$&#34;)
        ax.plot(x[Gm], y[Gm], &#34;o&#34;, ms=7, c=c_Gm, label=r&#34;$\Gamma &lt; 0$&#34;)

        # plot center of mass
        x_cm, y_cm = self.cm()
        s_cm = f&#34;({x_cm:.4g}, {y_cm:.4g})&#34;
        ax.plot(x_cm, y_cm, &#34;*&#34;, ms=13, c=&#34;gold&#34;, label=f&#34;center of mass\n{s_cm}&#34;)

        # 2nd mom
        x_cm2, y_cm2 = self.mom(2)
        s_cm2 = f&#34;({x_cm2:.4g}, {y_cm2:.4g})&#34;
        ax.plot(x_cm2, y_cm2, &#34;*&#34;, ms=13, c=&#34;0.4&#34;, label=f&#34;mom2\n{s_cm2}&#34;)

        # 3nd mom
        # TODO: helper fn to DRY this
        x_cm3, y_cm3 = self.mom(3)
        s_cm3 = f&#34;({x_cm3:.4g}, {y_cm3:.4g})&#34;
        ax.plot(x_cm3, y_cm3, &#34;*&#34;, ms=13, c=&#34;0.55&#34;, label=f&#34;mom3\n{s_cm3}&#34;)

        ax.set(
            title=f&#34;$C = {self.C():.4g}$&#34;,
            xlabel=&#34;$x$&#34;,
            ylabel=&#34;$y$&#34;,
        )
        ax.set_aspect(&#34;equal&#34;, &#34;datalim&#34;)
        fig.legend()
        ax.grid(True)
        fig.tight_layout()

        # return


    def mom(self, n, *, abs_G=False, center=False):
        r&#34;&#34;&#34;Compute `n`-th moment.

        Parameters
        ----------
        n : int
            Which [moment](https://en.wikipedia.org/wiki/Moment_(mathematics)) to calculate.
        abs_G : bool
            Whether to take the absolute value of the $\Gamma$ values (false by default).
        center : bool
            `True`: evaluate moment wrt. center of mass from `Vortons.cm`

            `False`: evaluate moment wrt. $(0, 0)$
        &#34;&#34;&#34;
        # seems like a moment but that might not be the correct terminology...
        G = self.G_col
        if abs_G:
            G = np.abs(G)
        G_tot = G.sum()

        x = self.state_mat  # x, y (columns)

        c = self.cm() if center else 0

        x_mom = (G * (x-c)**n).sum(axis=0) / G_tot  # sum along vortons dim, giving a position
        # ^ maybe this should be x - x_cm here...

        return x_mom


    # Chamecki notes suggest this should be called &#34;center of vorticity&#34; or &#34;linear impulse&#34;
    def center_of_mass(self):
        r&#34;&#34;&#34;Compute [center of mass](https://en.wikipedia.org/wiki/Center_of_mass#A_system_of_particles)
        using $\Gamma$ (`Vortons.G`) as mass.
        Equivalent to `Vortons.mom` with `n=1`, `abs_G=True` (currently), `center=False`.
        &#34;&#34;&#34;
        # TODO: what impact should sign of G have on cm? mass is always pos. but G can be neg.
        return self.mom(1, abs_G=True, center=False)

    def cm(self):
        &#34;&#34;&#34;Alias for `Vortons.center_of_mass`.&#34;&#34;&#34;
        return self.center_of_mass()

    def center_coords(self, inplace=False):
        &#34;&#34;&#34;Make $(0, 0)$ the center of mass.&#34;&#34;&#34;
        xy_cm = self.cm()
        x_cm, y_cm = xy_cm
        if not inplace:
            return Vortons(self.G, self.x-x_cm, self.y-y_cm)
        else:
            self.state_mat -= x_cm


    @staticmethod
    def regular_polygon(n, *, G=None, **kwargs):  # TODO: this and the below should be made classmethod since they return class instance
        r&#34;&#34;&#34;Create Vortons with positions corresponding to regular polygon.

        Parameters
        ----------
        n : int
            Polygon order.
        G : int, array-like, optional
            $\Gamma$ value(s) to use.

            Single value or array of values

            default: 1.0

        `**kwargs` are passed on to `regular_polygon_vertices`.
        &#34;&#34;&#34;
        if G is None:
            G = 1.0  # default
        G = np.asarray(G)
        if G.size == 1:  # single G provided, or using the default
            G = np.full((n,), G)  # TODO: could also the constructor to accept single G
        if G.size != n:
            raise ValueError(f&#34;`G` must have size `n` or 1, but is {G.size!r}&#34;)

        xy = regular_polygon_vertices(n, **kwargs).T  # x, y cols-&gt; rows (for unpacking)

        return Vortons(G, *xy)


    @staticmethod
    def isos_triangle(*, G=None, **kwargs):
        &#34;&#34;&#34;Create Vortons with isosceles triangle vertices.

        `**kwargs` are passed on to `isos_triangle_vertices`.
        &#34;&#34;&#34;
        G = _maybe_fill_G(G, 3)

        xy = isos_triangle_vertices(**kwargs).T

        return Vortons(G, *xy)


    def maybe_with_tracers(self, tracers: Tracers = None):
        &#34;&#34;&#34;Return new `Vortons` with the tracers (maybe) included.

        .. caution::
           Temporary? hack to get full (combined) `state_vec` for the whole system.

        If `Tracers` is `None`, just returns `self`.
        &#34;&#34;&#34;
        if tracers is None:
            return self

        # TODO: add option to extend existing Vortons instead of creating a new. `inplace`?

        G_v = self.G
        xy_v = self.state_mat
        xy_t = tracers.state_mat
        G_t = np.zeros((tracers.n,))

        G = np.append(G_v, G_t)
        x, y = np.append(xy_v, xy_t, axis=0).T  # unpacking arrays goes by rows

        return Vortons(G, x, y)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="vorts.vortons.Vortons.isos_triangle"><code class="name flex">
<span>def <span class="ident">isos_triangle</span></span>(<span>*, G=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Create Vortons with isosceles triangle vertices.</p>
<p><code>**kwargs</code> are passed on to <code><a title="vorts.vortons.isos_triangle_vertices" href="#vorts.vortons.isos_triangle_vertices">isos_triangle_vertices()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/zmoon/vorts/blob/72f11de365abad6b6dc355c92609ad20e8ead8ce/vorts\vortons.py#L421-L431" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def isos_triangle(*, G=None, **kwargs):
    &#34;&#34;&#34;Create Vortons with isosceles triangle vertices.

    `**kwargs` are passed on to `isos_triangle_vertices`.
    &#34;&#34;&#34;
    G = _maybe_fill_G(G, 3)

    xy = isos_triangle_vertices(**kwargs).T

    return Vortons(G, *xy)</code></pre>
</details>
</dd>
<dt id="vorts.vortons.Vortons.regular_polygon"><code class="name flex">
<span>def <span class="ident">regular_polygon</span></span>(<span>n, *, G=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Create Vortons with positions corresponding to regular polygon.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code></dt>
<dd>Polygon order.</dd>
<dt><strong><code>G</code></strong> :&ensp;<code>int, array-like</code>, optional</dt>
<dd>
<p>$\Gamma$ value(s) to use.</p>
<p>Single value or array of values</p>
<p>default: 1.0</p>
</dd>
</dl>
<p><code>**kwargs</code> are passed on to <code><a title="vorts.vortons.regular_polygon_vertices" href="#vorts.vortons.regular_polygon_vertices">regular_polygon_vertices()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/zmoon/vorts/blob/72f11de365abad6b6dc355c92609ad20e8ead8ce/vorts\vortons.py#L391-L418" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def regular_polygon(n, *, G=None, **kwargs):  # TODO: this and the below should be made classmethod since they return class instance
    r&#34;&#34;&#34;Create Vortons with positions corresponding to regular polygon.

    Parameters
    ----------
    n : int
        Polygon order.
    G : int, array-like, optional
        $\Gamma$ value(s) to use.

        Single value or array of values

        default: 1.0

    `**kwargs` are passed on to `regular_polygon_vertices`.
    &#34;&#34;&#34;
    if G is None:
        G = 1.0  # default
    G = np.asarray(G)
    if G.size == 1:  # single G provided, or using the default
        G = np.full((n,), G)  # TODO: could also the constructor to accept single G
    if G.size != n:
        raise ValueError(f&#34;`G` must have size `n` or 1, but is {G.size!r}&#34;)

    xy = regular_polygon_vertices(n, **kwargs).T  # x, y cols-&gt; rows (for unpacking)

    return Vortons(G, *xy)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="vorts.vortons.Vortons.G"><code class="name">var <span class="ident">G</span></code></dt>
<dd>
<div class="desc"><p>Array of vorton strengths ($\Gamma$).</p></div>
</dd>
<dt id="vorts.vortons.Vortons.G_col"><code class="name">var <span class="ident">G_col</span></code></dt>
<dd>
<div class="desc"><p><code><a title="vorts.vortons.Vortons.G" href="#vorts.vortons.Vortons.G">Vortons.G</a></code> as a column vector.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/zmoon/vorts/blob/72f11de365abad6b6dc355c92609ad20e8ead8ce/vorts\vortons.py#L176-L179" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def G_col(self):
    &#34;&#34;&#34;`Vortons.G` as a column vector.&#34;&#34;&#34;
    return self.G[:, np.newaxis]</code></pre>
</details>
</dd>
<dt id="vorts.vortons.Vortons.n"><code class="name">var <span class="ident">n</span></code></dt>
<dd>
<div class="desc"><p>Number of vortons.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/zmoon/vorts/blob/72f11de365abad6b6dc355c92609ad20e8ead8ce/vorts\vortons.py#L194-L198" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def n(self):
    &#34;&#34;&#34;Number of vortons.&#34;&#34;&#34;
    # numpy.ndarray size lookups are esentially free
    return self.G.size  # will have to change if want to allow single G at some point</code></pre>
</details>
</dd>
<dt id="vorts.vortons.Vortons.state_mat"><code class="name">var <span class="ident">state_mat</span></code></dt>
<dd>
<div class="desc"><p>2-d array of $(x, y)$ coordinates &ndash; each row is the coordinate of one vorton.</p></div>
</dd>
<dt id="vorts.vortons.Vortons.x"><code class="name">var <span class="ident">x</span></code></dt>
<dd>
<div class="desc"><p>Array of $x$ positions (a view into <code><a title="vorts.vortons.Vortons.state_mat" href="#vorts.vortons.Vortons.state_mat">Vortons.state_mat</a></code>).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/zmoon/vorts/blob/72f11de365abad6b6dc355c92609ad20e8ead8ce/vorts\vortons.py#L181-L187" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def x(self):
    &#34;&#34;&#34;Array of $x$ positions (a view into `Vortons.state_mat`).&#34;&#34;&#34;
    # slice indexing should give just a view into `self.state_mat`
    # thus `self.x.base` will return the state mat
    # i.e., `vs.x.base is vs.state_mat`
    return self.state_mat[:,0]</code></pre>
</details>
</dd>
<dt id="vorts.vortons.Vortons.y"><code class="name">var <span class="ident">y</span></code></dt>
<dd>
<div class="desc"><p>Array of $y$ positions (a view into <code><a title="vorts.vortons.Vortons.state_mat" href="#vorts.vortons.Vortons.state_mat">Vortons.state_mat</a></code>).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/zmoon/vorts/blob/72f11de365abad6b6dc355c92609ad20e8ead8ce/vorts\vortons.py#L189-L192" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def y(self):
    &#34;&#34;&#34;Array of $y$ positions (a view into `Vortons.state_mat`).&#34;&#34;&#34;
    return self.state_mat[:,1]</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="vorts.vortons.Vortons.C"><code class="name flex">
<span>def <span class="ident">C</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate $C$.</p>
<p>$$
C = \sum_{\alpha, \beta = 1; \alpha \neq \beta}^{N}
\Gamma_{\alpha} \Gamma_{\beta} l_{\alpha \beta}^{2}
$$</p>
<p>$C$ is supposed to be a conserved quantity in this system.
&ndash; Chamecki (2005) eq. 15, which references Aref (1979)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/zmoon/vorts/blob/72f11de365abad6b6dc355c92609ad20e8ead8ce/vorts\vortons.py#L210-L235" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def C(self):
    r&#34;&#34;&#34;Calculate $C$.

    $$
    C = \sum_{\alpha, \beta = 1; \alpha \neq \beta}^{N}
        \Gamma_{\alpha} \Gamma_{\beta} l_{\alpha \beta}^{2}
    $$

    $C$ is supposed to be a conserved quantity in this system.
    -- Chamecki (2005) eq. 15, which references Aref (1979)
    &#34;&#34;&#34;
    n_vortons = self.n
    G = self.G
    C = 0
    for i, j in zip(*np.triu_indices(n_vortons, 1)):  # all combinations without repetition

        xi, yi = self.x[i], self.y[i]
        xj, yj = self.x[j], self.y[j]

        lij_sqd = (xi-xj)**2 + (yi-yj)**2

        Gi, Gj = G[i], G[j]

        C += Gi * Gj * lij_sqd

    return C</code></pre>
</details>
</dd>
<dt id="vorts.vortons.Vortons.H"><code class="name flex">
<span>def <span class="ident">H</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate $H$, the Hamiltonian of the system.</p>
<p>$$
H = -\frac{1}{4 \pi} \sum_{\alpha, \beta = 1; \alpha \neq \beta}^{N}
\Gamma_{\alpha} \Gamma_{\beta}
\ln | r_{\alpha} - r_{\beta} |
$$</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/zmoon/vorts/blob/72f11de365abad6b6dc355c92609ad20e8ead8ce/vorts\vortons.py#L238-L256" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def H(self):
    r&#34;&#34;&#34;Calculate $H$, the Hamiltonian of the system.

    $$
    H = -\frac{1}{4 \pi} \sum_{\alpha, \beta = 1; \alpha \neq \beta}^{N}
        \Gamma_{\alpha} \Gamma_{\beta}
        \ln | r_{\alpha} - r_{\beta} |
    $$
    &#34;&#34;&#34;
    nv = self.n
    G = self.G
    r = self.state_mat  # vorton positions
    H = 0
    for a, b in zip(*np.triu_indices(nv, 1)):
        ra, rb = r[a], r[b]
        Ga, Gb = G[a], G[b]
        H += -1/(4*np.pi) * Ga * Gb * np.log(np.linalg.norm(ra - rb))

    return H</code></pre>
</details>
</dd>
<dt id="vorts.vortons.Vortons.I"><code class="name flex">
<span>def <span class="ident">I</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate $I$, the angular impulse of the system.</p>
<p>$$
I = \sum_{\alpha = 1}^{N} \Gamma_{\alpha} | r_{\alpha} |^2
$$</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/zmoon/vorts/blob/72f11de365abad6b6dc355c92609ad20e8ead8ce/vorts\vortons.py#L259-L273" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def I(self):
    r&#34;&#34;&#34;Calculate $I$, the angular impulse of the system.

    $$
    I = \sum_{\alpha = 1}^{N} \Gamma_{\alpha} | r_{\alpha} |^2
    $$
    &#34;&#34;&#34;
    G = self.G
    # r = self.state_mat
    x = self.x
    y = self.y

    # r_hat_sqd =

    return (G * (x**2 + y**2)).sum()</code></pre>
</details>
</dd>
<dt id="vorts.vortons.Vortons.center_coords"><code class="name flex">
<span>def <span class="ident">center_coords</span></span>(<span>self, inplace=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Make $(0, 0)$ the center of mass.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/zmoon/vorts/blob/72f11de365abad6b6dc355c92609ad20e8ead8ce/vorts\vortons.py#L381-L388" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def center_coords(self, inplace=False):
    &#34;&#34;&#34;Make $(0, 0)$ the center of mass.&#34;&#34;&#34;
    xy_cm = self.cm()
    x_cm, y_cm = xy_cm
    if not inplace:
        return Vortons(self.G, self.x-x_cm, self.y-y_cm)
    else:
        self.state_mat -= x_cm</code></pre>
</details>
</dd>
<dt id="vorts.vortons.Vortons.center_of_mass"><code class="name flex">
<span>def <span class="ident">center_of_mass</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute <a href="https://en.wikipedia.org/wiki/Center_of_mass#A_system_of_particles">center of mass</a>
using $\Gamma$ (<code><a title="vorts.vortons.Vortons.G" href="#vorts.vortons.Vortons.G">Vortons.G</a></code>) as mass.
Equivalent to <code><a title="vorts.vortons.Vortons.mom" href="#vorts.vortons.Vortons.mom">Vortons.mom()</a></code> with <code>n=1</code>, <code>abs_G=True</code> (currently), <code>center=False</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/zmoon/vorts/blob/72f11de365abad6b6dc355c92609ad20e8ead8ce/vorts\vortons.py#L369-L375" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def center_of_mass(self):
    r&#34;&#34;&#34;Compute [center of mass](https://en.wikipedia.org/wiki/Center_of_mass#A_system_of_particles)
    using $\Gamma$ (`Vortons.G`) as mass.
    Equivalent to `Vortons.mom` with `n=1`, `abs_G=True` (currently), `center=False`.
    &#34;&#34;&#34;
    # TODO: what impact should sign of G have on cm? mass is always pos. but G can be neg.
    return self.mom(1, abs_G=True, center=False)</code></pre>
</details>
</dd>
<dt id="vorts.vortons.Vortons.cm"><code class="name flex">
<span>def <span class="ident">cm</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias for <code><a title="vorts.vortons.Vortons.center_of_mass" href="#vorts.vortons.Vortons.center_of_mass">Vortons.center_of_mass()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/zmoon/vorts/blob/72f11de365abad6b6dc355c92609ad20e8ead8ce/vorts\vortons.py#L377-L379" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def cm(self):
    &#34;&#34;&#34;Alias for `Vortons.center_of_mass`.&#34;&#34;&#34;
    return self.center_of_mass()</code></pre>
</details>
</dd>
<dt id="vorts.vortons.Vortons.maybe_with_tracers"><code class="name flex">
<span>def <span class="ident">maybe_with_tracers</span></span>(<span>self, tracers: <a title="vorts.vortons.Tracers" href="#vorts.vortons.Tracers">Tracers</a> = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return new <code><a title="vorts.vortons.Vortons" href="#vorts.vortons.Vortons">Vortons</a></code> with the tracers (maybe) included.</p>
<div class="admonition caution">
<p class="admonition-title">Caution</p>
<p>Temporary? hack to get full (combined) <code>state_vec</code> for the whole system.</p>
</div>
<p>If <code><a title="vorts.vortons.Tracers" href="#vorts.vortons.Tracers">Tracers</a></code> is <code>None</code>, just returns <code>self</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/zmoon/vorts/blob/72f11de365abad6b6dc355c92609ad20e8ead8ce/vorts\vortons.py#L434-L455" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def maybe_with_tracers(self, tracers: Tracers = None):
    &#34;&#34;&#34;Return new `Vortons` with the tracers (maybe) included.

    .. caution::
       Temporary? hack to get full (combined) `state_vec` for the whole system.

    If `Tracers` is `None`, just returns `self`.
    &#34;&#34;&#34;
    if tracers is None:
        return self

    # TODO: add option to extend existing Vortons instead of creating a new. `inplace`?

    G_v = self.G
    xy_v = self.state_mat
    xy_t = tracers.state_mat
    G_t = np.zeros((tracers.n,))

    G = np.append(G_v, G_t)
    x, y = np.append(xy_v, xy_t, axis=0).T  # unpacking arrays goes by rows

    return Vortons(G, x, y)</code></pre>
</details>
</dd>
<dt id="vorts.vortons.Vortons.mom"><code class="name flex">
<span>def <span class="ident">mom</span></span>(<span>self, n, *, abs_G=False, center=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute <code>n</code>-th moment.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code></dt>
<dd>Which <a href="https://en.wikipedia.org/wiki/Moment_(mathematics)">moment</a> to calculate.</dd>
<dt><strong><code>abs_G</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to take the absolute value of the $\Gamma$ values (false by default).</dd>
<dt><strong><code>center</code></strong> :&ensp;<code>bool</code></dt>
<dd>
<p><code>True</code>: evaluate moment wrt. center of mass from <code><a title="vorts.vortons.Vortons.cm" href="#vorts.vortons.Vortons.cm">Vortons.cm()</a></code></p>
<p><code>False</code>: evaluate moment wrt. $(0, 0)$</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/zmoon/vorts/blob/72f11de365abad6b6dc355c92609ad20e8ead8ce/vorts\vortons.py#L338-L365" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def mom(self, n, *, abs_G=False, center=False):
    r&#34;&#34;&#34;Compute `n`-th moment.

    Parameters
    ----------
    n : int
        Which [moment](https://en.wikipedia.org/wiki/Moment_(mathematics)) to calculate.
    abs_G : bool
        Whether to take the absolute value of the $\Gamma$ values (false by default).
    center : bool
        `True`: evaluate moment wrt. center of mass from `Vortons.cm`

        `False`: evaluate moment wrt. $(0, 0)$
    &#34;&#34;&#34;
    # seems like a moment but that might not be the correct terminology...
    G = self.G_col
    if abs_G:
        G = np.abs(G)
    G_tot = G.sum()

    x = self.state_mat  # x, y (columns)

    c = self.cm() if center else 0

    x_mom = (G * (x-c)**n).sum(axis=0) / G_tot  # sum along vortons dim, giving a position
    # ^ maybe this should be x - x_cm here...

    return x_mom</code></pre>
</details>
</dd>
<dt id="vorts.vortons.Vortons.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot the vortons.
(Only their current positions, which are all <code><a title="vorts.vortons.Vortons" href="#vorts.vortons.Vortons">Vortons</a></code> knows about.)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/zmoon/vorts/blob/72f11de365abad6b6dc355c92609ad20e8ead8ce/vorts\vortons.py#L292-L333" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def plot(self):
    &#34;&#34;&#34;Plot the vortons.
    (Only their current positions, which are all `Vortons` knows about.)
    &#34;&#34;&#34;
    import matplotlib.pyplot as plt

    fig, ax = plt.subplots()

    # plot vorton positions
    c_Gp = &#34;cadetblue&#34;
    c_Gm = &#34;salmon&#34;
    G = self.G
    Gp, Gm = G &gt; 0, G &lt; 0
    x, y = self.x, self.y
    ax.plot(x[Gp], y[Gp], &#34;o&#34;, ms=7, c=c_Gp, label=r&#34;$\Gamma &gt; 0$&#34;)
    ax.plot(x[Gm], y[Gm], &#34;o&#34;, ms=7, c=c_Gm, label=r&#34;$\Gamma &lt; 0$&#34;)

    # plot center of mass
    x_cm, y_cm = self.cm()
    s_cm = f&#34;({x_cm:.4g}, {y_cm:.4g})&#34;
    ax.plot(x_cm, y_cm, &#34;*&#34;, ms=13, c=&#34;gold&#34;, label=f&#34;center of mass\n{s_cm}&#34;)

    # 2nd mom
    x_cm2, y_cm2 = self.mom(2)
    s_cm2 = f&#34;({x_cm2:.4g}, {y_cm2:.4g})&#34;
    ax.plot(x_cm2, y_cm2, &#34;*&#34;, ms=13, c=&#34;0.4&#34;, label=f&#34;mom2\n{s_cm2}&#34;)

    # 3nd mom
    # TODO: helper fn to DRY this
    x_cm3, y_cm3 = self.mom(3)
    s_cm3 = f&#34;({x_cm3:.4g}, {y_cm3:.4g})&#34;
    ax.plot(x_cm3, y_cm3, &#34;*&#34;, ms=13, c=&#34;0.55&#34;, label=f&#34;mom3\n{s_cm3}&#34;)

    ax.set(
        title=f&#34;$C = {self.C():.4g}$&#34;,
        xlabel=&#34;$x$&#34;,
        ylabel=&#34;$y$&#34;,
    )
    ax.set_aspect(&#34;equal&#34;, &#34;datalim&#34;)
    fig.legend()
    ax.grid(True)
    fig.tight_layout()</code></pre>
</details>
</dd>
<dt id="vorts.vortons.Vortons.state_mat_full"><code class="name flex">
<span>def <span class="ident">state_mat_full</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return full state matrix: (<code><a title="vorts.vortons.Vortons.G" href="#vorts.vortons.Vortons.G">Vortons.G</a></code>, <code><a title="vorts.vortons.Vortons.x" href="#vorts.vortons.Vortons.x">Vortons.x</a></code>, <code><a title="vorts.vortons.Vortons.y" href="#vorts.vortons.Vortons.y">Vortons.y</a></code>) as 3 columns.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/zmoon/vorts/blob/72f11de365abad6b6dc355c92609ad20e8ead8ce/vorts\vortons.py#L171-L173" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def state_mat_full(self):
    &#34;&#34;&#34;Return full state matrix: (`Vortons.G`, `Vortons.x`, `Vortons.y`) as 3 columns.&#34;&#34;&#34;
    return np.column_stack((self.G, self.state_mat))</code></pre>
</details>
</dd>
<dt id="vorts.vortons.Vortons.state_vec"><code class="name flex">
<span>def <span class="ident">state_vec</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return flattened state matrix (<code><a title="vorts.vortons.Vortons.state_mat" href="#vorts.vortons.Vortons.state_mat">Vortons.state_mat</a></code>; <code><a title="vorts.vortons.Vortons.G" href="#vorts.vortons.Vortons.G">Vortons.G</a></code> not included).</p>
<p>If using <code><a title="vorts.py.integ.integrate_scipy" href="py/integ.html#vorts.py.integ.integrate_scipy">integrate_scipy()</a></code>,
this is needed to feed to <a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.solve_ivp.html"><code>scipy.integrate.solve_ivp</code></a>,
which requires a 1-d array for its <code>y0</code> input.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/zmoon/vorts/blob/72f11de365abad6b6dc355c92609ad20e8ead8ce/vorts\vortons.py#L161-L168" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def state_vec(self):
    &#34;&#34;&#34;Return flattened state matrix (`Vortons.state_mat`; `Vortons.G` not included).

    If using `vorts.py.integ.integrate_scipy`,
    this is needed to feed to [`scipy.integrate.solve_ivp`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.solve_ivp.html),
    which requires a 1-d array for its `y0` input.
    &#34;&#34;&#34;
    return self.state_mat.T.flatten()  # TODO: change to ravel, to return view when possible</code></pre>
</details>
</dd>
<dt id="vorts.vortons.Vortons.theta"><code class="name flex">
<span>def <span class="ident">theta</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate $\theta$, the action angles??</p>
<p>Chamecki eq. 19</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/zmoon/vorts/blob/72f11de365abad6b6dc355c92609ad20e8ead8ce/vorts\vortons.py#L280-L289" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def theta(self):
    r&#34;&#34;&#34;Calculate $\theta$, the action angles??

    Chamecki eq. 19
    &#34;&#34;&#34;
    N = self.n
    I = self.I()
    H = self.H()

    return (2/(N-1))**(N*(N-1)/2) * I**(N*(N-1)) * np.exp(4*np.pi*H)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<h1 style="margin-top: -16px;">
<a class="homelink" rel="home" title="vorts Home" href="https://zmoon.github.io/vorts/">
vorts
</a>
</h1>
</header>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="vorts" href="index.html">vorts</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="vorts.vortons.isos_triangle_vertices" href="#vorts.vortons.isos_triangle_vertices">isos_triangle_vertices</a></code></li>
<li><code><a title="vorts.vortons.points_grid" href="#vorts.vortons.points_grid">points_grid</a></code></li>
<li><code><a title="vorts.vortons.points_randn" href="#vorts.vortons.points_randn">points_randn</a></code></li>
<li><code><a title="vorts.vortons.points_randu" href="#vorts.vortons.points_randu">points_randu</a></code></li>
<li><code><a title="vorts.vortons.points_spiral" href="#vorts.vortons.points_spiral">points_spiral</a></code></li>
<li><code><a title="vorts.vortons.regular_polygon_vertices" href="#vorts.vortons.regular_polygon_vertices">regular_polygon_vertices</a></code></li>
<li><code><a title="vorts.vortons.rotate_2d" href="#vorts.vortons.rotate_2d">rotate_2d</a></code></li>
<li><code><a title="vorts.vortons.rotmat_2d" href="#vorts.vortons.rotmat_2d">rotmat_2d</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="vorts.vortons.Tracer" href="#vorts.vortons.Tracer">Tracer</a></code></h4>
<ul class="">
<li><code><a title="vorts.vortons.Tracer.x" href="#vorts.vortons.Tracer.x">x</a></code></li>
<li><code><a title="vorts.vortons.Tracer.y" href="#vorts.vortons.Tracer.y">y</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vorts.vortons.Tracers" href="#vorts.vortons.Tracers">Tracers</a></code></h4>
<ul class="two-column">
<li><code><a title="vorts.vortons.Tracers.n" href="#vorts.vortons.Tracers.n">n</a></code></li>
<li><code><a title="vorts.vortons.Tracers.plot" href="#vorts.vortons.Tracers.plot">plot</a></code></li>
<li><code><a title="vorts.vortons.Tracers.randu" href="#vorts.vortons.Tracers.randu">randu</a></code></li>
<li><code><a title="vorts.vortons.Tracers.spiral" href="#vorts.vortons.Tracers.spiral">spiral</a></code></li>
<li><code><a title="vorts.vortons.Tracers.state_mat_full" href="#vorts.vortons.Tracers.state_mat_full">state_mat_full</a></code></li>
<li><code><a title="vorts.vortons.Tracers.state_vec" href="#vorts.vortons.Tracers.state_vec">state_vec</a></code></li>
<li><code><a title="vorts.vortons.Tracers.x" href="#vorts.vortons.Tracers.x">x</a></code></li>
<li><code><a title="vorts.vortons.Tracers.y" href="#vorts.vortons.Tracers.y">y</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vorts.vortons.Vorton" href="#vorts.vortons.Vorton">Vorton</a></code></h4>
<ul class="">
<li><code><a title="vorts.vortons.Vorton.G" href="#vorts.vortons.Vorton.G">G</a></code></li>
<li><code><a title="vorts.vortons.Vorton.x" href="#vorts.vortons.Vorton.x">x</a></code></li>
<li><code><a title="vorts.vortons.Vorton.y" href="#vorts.vortons.Vorton.y">y</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vorts.vortons.Vortons" href="#vorts.vortons.Vortons">Vortons</a></code></h4>
<ul class="two-column">
<li><code><a title="vorts.vortons.Vortons.C" href="#vorts.vortons.Vortons.C">C</a></code></li>
<li><code><a title="vorts.vortons.Vortons.G" href="#vorts.vortons.Vortons.G">G</a></code></li>
<li><code><a title="vorts.vortons.Vortons.G_col" href="#vorts.vortons.Vortons.G_col">G_col</a></code></li>
<li><code><a title="vorts.vortons.Vortons.H" href="#vorts.vortons.Vortons.H">H</a></code></li>
<li><code><a title="vorts.vortons.Vortons.I" href="#vorts.vortons.Vortons.I">I</a></code></li>
<li><code><a title="vorts.vortons.Vortons.center_coords" href="#vorts.vortons.Vortons.center_coords">center_coords</a></code></li>
<li><code><a title="vorts.vortons.Vortons.center_of_mass" href="#vorts.vortons.Vortons.center_of_mass">center_of_mass</a></code></li>
<li><code><a title="vorts.vortons.Vortons.cm" href="#vorts.vortons.Vortons.cm">cm</a></code></li>
<li><code><a title="vorts.vortons.Vortons.isos_triangle" href="#vorts.vortons.Vortons.isos_triangle">isos_triangle</a></code></li>
<li><code><a title="vorts.vortons.Vortons.maybe_with_tracers" href="#vorts.vortons.Vortons.maybe_with_tracers">maybe_with_tracers</a></code></li>
<li><code><a title="vorts.vortons.Vortons.mom" href="#vorts.vortons.Vortons.mom">mom</a></code></li>
<li><code><a title="vorts.vortons.Vortons.n" href="#vorts.vortons.Vortons.n">n</a></code></li>
<li><code><a title="vorts.vortons.Vortons.plot" href="#vorts.vortons.Vortons.plot">plot</a></code></li>
<li><code><a title="vorts.vortons.Vortons.regular_polygon" href="#vorts.vortons.Vortons.regular_polygon">regular_polygon</a></code></li>
<li><code><a title="vorts.vortons.Vortons.state_mat" href="#vorts.vortons.Vortons.state_mat">state_mat</a></code></li>
<li><code><a title="vorts.vortons.Vortons.state_mat_full" href="#vorts.vortons.Vortons.state_mat_full">state_mat_full</a></code></li>
<li><code><a title="vorts.vortons.Vortons.state_vec" href="#vorts.vortons.Vortons.state_vec">state_vec</a></code></li>
<li><code><a title="vorts.vortons.Vortons.theta" href="#vorts.vortons.Vortons.theta">theta</a></code></li>
<li><code><a title="vorts.vortons.Vortons.x" href="#vorts.vortons.Vortons.x">x</a></code></li>
<li><code><a title="vorts.vortons.Vortons.y" href="#vorts.vortons.Vortons.y">y</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<span style="color:#777777">&copy; Z. Moon 2020</span>
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>